#!/usr/bin/env php
<?php

use TBela\CSS\Cli\Args;
use TBela\CSS\Cli\Exceptions\MissingParameterException;
use TBela\CSS\Cli\Option;
use TBela\CSS\Parser;
use TBela\CSS\Renderer;

require __DIR__ . '/../vendor/autoload.php';
require __DIR__.'/../src/compat.php';

// only use from the cli
if (PHP_SAPI != 'cli') {

    fwrite(STDERR, 'this program must be executed from the cli');
    exit(1);
}

spl_autoload_register(function ($name) {

    $parts = explode('\\', $name);

    if ($parts[0] == 'TBela' && isset($parts[1]) && $parts[1] == 'CSS') {

        array_splice($parts, 0, 2);
        array_unshift($parts, 'src');
    }

    $path = __DIR__ . '/../' . implode('/', $parts) . '.php';

    if (is_file($path)) {

        require($path);
    }
});

$cli = new Args($argv);
$exe = $cli->getExe();

try {

        $data = json_decode(file_get_contents(__DIR__ . '/../package.json'), JSON_OBJECT_AS_ARRAY);
        $metadata = json_decode(file_get_contents(__DIR__ . '/../composer.json'), JSON_OBJECT_AS_ARRAY);

        $version = sprintf("%s (version %s)
Copyright (C) %s %s.
Dual licensed under MIT or LGPL v3\n", $cli->getExe(), $data['version'], date('Y'), implode(', ', array_map(function ($author) {

            return $author['name'];
        }, $metadata['authors'])));

    $cli->
<<<<<<< HEAD
    setStrict(true)->
    add('version', 'print version number', Option::BOOL, 'v', false)
        ->addGroup('internal', "internal commands are used by the multithreading feature:\n", true)
        ->add('parse-ast-src', 'src value of the ast nodes', Option::STRING, null,false, false, null, [], null, 'internal')
        ->add('parse-ast-position-index', 'initial index position of the ast nodes', Option::INT, null,false, false, null, [], null, 'internal')
        ->add('parse-ast-position-line', 'initial line number of the ast nodes', Option::INT, null,false, false, null, [], null, 'internal')
        ->add('parse-ast-position-column', 'initial column number of the ast nodes', Option::INT, null, false,false, null, [], null, 'internal')
        ->addGroup('parse', "Parse options:\n")
        ->add('capture-errors', 'ignore parse error', Option::BOOL, 'e', false, false, null, [], null, 'parse')
        ->add('flatten-import', 'process @import', Option::BOOL, 'm', false, false, null, [], null, 'parse')
        ->add('parse-allow-duplicate-rules', 'allow duplicate rule', Option::BOOL, 'p', false, false, null, [], null, 'parse')
        ->add('parse-allow-duplicate-declarations', 'allow duplicate declaration', Option::AUTO, 'd', false, false, null, [], null, 'parse')
        ->add('file', 'input css file or url', Option::STRING, 'f', true, false, null, [], null, 'parse')
        ->add('parse-multi-processing', 'enable multi-processing parser', Option::BOOL, 'M', false, false, true, [], null, 'parse')
        ->add('parse-children-process', 'maximum children process', Option::INT, 'P', false, false, 20, [], null, 'parse')
        ->add('input-format', 'input format: json (ast), serialize (PHP serialized ast)', Option::STRING, 'I', false, false, Option::STRING, [Option::STRING, 'json', 'serialize'], null, 'parse')
        ->addGroup('render', "Render options:\n")
        ->add('css-level', 'css color module', Option::INT, 'l', false, false, 4, [3, 4], null, 'render')
        ->add('charset', 'remove @charset', Option::BOOL, 'S', false, false,  false, [], null, 'render')
        ->add('compress', 'minify output', Option::BOOL, 'c', false, false, null, [], null, 'render')
        ->add('sourcemap', 'generate sourcemap', Option::BOOL, 's', false, false, null, [],  'file', 'render')
        ->add('remove-comments', 'remove comments', Option::BOOL, 'C', false, false, null, [], null, 'render')
        ->add('preserve-license', 'preserve license comments', Option::BOOL, 'L', false, false, null, [], null, 'render')
        ->add('legacy-rendering', 'convert nested css syntax', Option::BOOL, 'G', false, false, null, [], null, 'render')
        ->add('compute-shorthand', 'compute shorthand properties', Option::BOOL, 'u', false, false, null, [], null, 'render')
        ->add('remove-empty-nodes', 'remove empty nodes', Option::BOOL, 'E', false, false, null, [], null, 'render')
        ->add('render-allow-duplicate-declarations', 'render duplicate declarations', Option::BOOL, 'r', false, false, null, [], null, 'render')
        ->add('convert-color', 'convert colors', Option::AUTO, 't', false, false, null, [true, false, 'hex', 'rgb', 'rgba', 'hsl', 'hsla', 'hwb', 'device-cmyk'], null, 'render')
        ->add('output', 'output file name', Option::STRING, 'o', false, false, null, [], null, 'render')
        ->add('ast', 'dump ast as JSON', Option::BOOL, 'a', false, false, null, [], null,'render')
        ->add('output-format', "output export format. string (css), json (ast), serialize (PHP serialized ast), json-array, serialize-array", Option::STRING, 'F', false, false, Option::STRING, [Option::STRING, 'json', 'serialize', 'json-array', 'serialize-array'], 'input-format', 'render')
        ->add('render-multi-processing', "enable multi-processing renderer", Option::BOOL, 'R', false, false,  true, [], null, 'render')
=======
    setStrict(true)
        ->addGroup('parse', "Parse options:\n")
        ->add('capture-errors', 'ignore parse error', Option::BOOL, 'e', multiple: false, group: 'parse')
        ->add('flatten-import', 'process @import', Option::BOOL, 'm', multiple: false, group: 'parse')
        ->add('parse-allow-duplicate-rules', 'allow duplicate rule', Option::BOOL, 'p', multiple: false, group: 'parse')
        ->add('parse-allow-duplicate-declarations', 'allow duplicate declaration', type: Option::AUTO, alias: 'd', multiple: false, group: 'parse')
        ->add('file', 'input css file or url', Option::STRING, 'f', group: 'parse')
        ->add('parse-multi-processing', 'enable multi-processing parser', Option::BOOL, 'M', multiple: false, defaultValue: true, group: 'parse')
        ->add('parse-children-process', 'maximum children process', Option::INT, 'P', multiple: false, defaultValue: 20, group: 'parse')
        ->add('input-format', 'input format: json (ast), string (plain css)', Option::STRING, 'I', multiple: false, defaultValue: 'string', options: ['string', 'json'], group: 'parse')
        ->addGroup('render', "Render options:\n")
        ->add('css-level', 'css color module', Option::INT, 'l', multiple: false, defaultValue: 4, options: [3, 4], group: 'render')
        ->add('charset', 'remove @charset', Option::BOOL, 'S', multiple: false, defaultValue: false, group: 'render')
        ->add('compress', 'minify output', Option::BOOL, 'c', multiple: false, group: 'render')
        ->add('sourcemap', 'generate sourcemap', Option::BOOL, 's', multiple: false, dependsOn: 'file', group: 'render')
        ->add('remove-comments', 'remove comments', Option::BOOL, 'C', multiple: false, group: 'render')
        ->add('preserve-license', 'preserve license comments', Option::BOOL, 'L', multiple: false, group: 'render')
        ->add('legacy-rendering', 'convert nested css syntax', Option::BOOL, 'G', multiple: false, group: 'render')
        ->add('compute-shorthand', 'compute shorthand properties', Option::BOOL, 'u', multiple: false, group: 'render')
        ->add('remove-empty-nodes', 'remove empty nodes', Option::BOOL, 'E', multiple: false, group: 'render')
        ->add('render-allow-duplicate-declarations', 'render duplicate declarations', Option::BOOL, 'r', multiple: false, group: 'render')
        ->add('convert-color', 'convert colors', Option::AUTO, 't', multiple: false, options: [true, false, 'hex', 'rgb', 'rgba', 'hsl', 'hsla', 'hwb', 'device-cmyk'], group: 'render')
        ->add('output', 'output file name', Option::STRING, 'o', multiple: false, group: 'render')
        ->add('ast', 'dump ast as JSON', Option::BOOL, 'a', multiple: false, group: 'render')
        ->add('render-multi-processing', "enable multi-processing renderer", Option::BOOL, 'R', multiple: false, defaultValue: true, group: 'render')
        ->setVersion($version)
        ->alias('version', 'v')
        ->help()
        ->alias('help', 'h')
>>>>>>> ba887b9f9f9c8efe3e2cf318c92afb782e93d4f5
        ->parse();

    $parseOptions = [];
    $renderOptions = [];

    $groups = $cli->getGroups();
    $args = $cli->getArguments();


    $pipeIn = !stream_isatty(STDIN);
    $pipeOut = !stream_isatty(STDOUT);

    $inFile = $pipeIn ? STDIN : (isset($args['file']) ? $args['file'] : null);
    $outFile = $pipeOut ? STDOUT : (isset($args['output']) ? $args['output'] : STDOUT);

    if ($inFile == STDIN) {

        if (!empty($args['file'])) {

            fwrite(STDERR, "> notice: ignoring parameter --file\n");
        }

        if (!empty($args['_'])) {

            fwrite(STDERR, "> notice: ignoring inline css\n" . json_encode($args['_'], JSON_PRETTY_PRINT) . "\n");
        }
    }

    if ($outFile == STDOUT && !empty($args['output'])) {

        fwrite(STDERR, "> notice: ignoring parameter --output\n");
    }

    foreach (array_keys($groups['parse']['arguments']) as $key) {

        if (isset($args[$key])) {

            $parseOptions[str_replace(['parse-', '-'], ['', '_'], $key)] = $args[$key];
        }
    }

    foreach (array_keys($groups['render']['arguments']) as $key) {

        if (isset($args[$key])) {

            $renderOptions[str_replace(['render-', '-'], ['', '_'], $key)] = $args[$key];
        }
    }

<<<<<<< HEAD
    foreach (array_keys($groups['internal']['arguments']) as $key) {

        if (isset($args[$key])) {

            if (\str_starts_with($key, 'parse-')) {

                $parseOptions[str_replace(['parse-', '-'], ['', '_'], $key)] = $args[$key];
            } else if (\str_starts_with($key, 'render-')) {

                $renderOptions[str_replace(['render-', '-'], ['', '_'], $key)] = $args[$key];
            }
        }
    }

    function read_input(array $parseOptions, $inFile)
=======
    function read_input(array $parseOptions, $inFile): Generator
>>>>>>> ba887b9f9f9c8efe3e2cf318c92afb782e93d4f5
    {

        if ($inFile == STDIN) {

            $data = file_get_contents('php://stdin');

<<<<<<< HEAD
            switch ($parseOptions['input_format']) {
                case   'serialize':
                    yield unserialize($data);
                    break;
                case 'json':
                    yield json_decode($data);
                    break;
                default:
                    yield $data;
                    break;
            }
        }

        else {
=======
            yield match ($parseOptions['input_format']) {
                'json' => json_decode($data),
                default => $data,
            };
        } else {
>>>>>>> ba887b9f9f9c8efe3e2cf318c92afb782e93d4f5

            foreach ((array)$inFile as $file) {

                if (!preg_match('#^(https?:)?//#', $file) && is_file($file)) {

                    $data = file_get_contents($file);

                } else {

                    $data = Parser\Helper::fetchContent($file);
                }

<<<<<<< HEAD
                switch($parseOptions['input_format']) {
                    case 'serialize':
                        yield  $file =>unserialize($data);
                        break;
                    case 'json':
                        yield  $file =>json_decode($data);
                        break;
                    default:
                        yield $file =>$data;
                        break;
=======
                yield $file => match ($parseOptions['input_format']) {
                    'json' => json_decode($data),
                    default => $data,
>>>>>>> ba887b9f9f9c8efe3e2cf318c92afb782e93d4f5
                };
            }
        }
    }

    $ast = [];
    $parser = new Parser('', $parseOptions);

    if ($parseOptions['input_format'] == 'string') {

        if ($inFile) {

            if ($inFile == STDIN) {

                $parser->appendContent(file_get_contents('php://stdin'));
            } else {

                foreach ((array)$inFile as $file) {

                    $parser->load($file);
                }
            }
        } else if (!empty($args['_'])) {

            $parser->appendContent(implode('', $args['_']));
        } else {

            // no input
            exit(0);
        }

        $ast = [$parser->getAst()];
    } else {

        // ast
        foreach (read_input($parseOptions, $inFile) as $data) {

            $ast[] = $data;
        }
    }

    if (empty($ast)) {

        exit(0);
    }

    $parser->setContent('');

    $root = (new Parser())->getAst();

    $root->children = $ast;
    $renderer = new Renderer($renderOptions);

    if ($outFile != STDOUT) {

        $renderer->save($root, $outFile);
    } else {

        fwrite($outFile, !empty($renderOptions['ast']) ? json_encode(count($ast) == 1 ? $ast[0] : $root, empty($renderOptions['compress']) ? JSON_PRETTY_PRINT : 0)
            : $renderer->renderAst($root));
    }

<<<<<<< HEAD
    else if (in_array($renderOptions['output_format'], ['json-array', 'serialize-array'])) {

        $output = [];

        foreach ($root->children as $node) {

            $nodes = $node->type == 'Stylesheet' ? $node->children : [$node];

            foreach ($nodes as $nod) {

                $css = $renderer->renderAst($nod);

                if (isset($output[$css])) {

                    unset($output[$css]);
                }

                $output[$css] = $css;
            }
        }

        fwrite($outFile, $renderOptions['output_format'] == 'serialize-array' ? serialize($output) : json_encode($output, empty($renderOptions['compress']) ? JSON_PRETTY_PRINT : 0));
    }

    else {

        $message = '';

        switch ($renderOptions['output_format']) {
            case 'json':
                $message = json_encode(count($ast) == 1 ? $ast[0] : $root, empty($renderOptions['compress']) ? JSON_PRETTY_PRINT : 0);
                break;
            case 'serialize':
                $message = serialize(count($ast) == 1 ? $ast[0] : $root);
                break;
            default:
                $message = $renderer->renderAst($root);
                break;
        }

        fwrite($outFile, $message);
    }


} catch (ValueError $e) {

    fwrite(STDERR, $e->getMessage() . "\n");
    $code = $e->getCode();
    exit($code == 0 ? 1 : $code);
}
catch (UnexpectedValueException $e) {

    fwrite(STDERR, $e->getMessage() . "\n");
    $code = $e->getCode();
    exit($code == 0 ? 1 : $code);
}
catch (InvalidArgumentException $e) {
=======
} catch (ValueError|UnexpectedValueException|InvalidArgumentException $e) {
>>>>>>> ba887b9f9f9c8efe3e2cf318c92afb782e93d4f5

    fwrite(STDERR, $e->getMessage() . "\n");
    $code = $e->getCode();
    exit($code == 0 ? 1 : $code);
} catch (MissingParameterException $e) {

    fwrite(STDERR, sprintf("%s: %s\nTry '%s --help'\n", $exe, $e->getMessage(), $exe));
    $code = $e->getCode();
    exit($code == 0 ? 1 : $code);
} catch (Throwable $e) {

    fwrite(STDERR, $e->getMessage() . "\n");
    exit(1);
}